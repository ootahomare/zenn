---
title: "CakePHP と DDD 〜レイヤードアーキテクチャの理想と妥協点〜"
emoji: "🦉"
type: "idea"
topics: ["CakePHP", "PHP8", "ドメイン駆動設計", "DDD"]
published: false
---

# CakePHP と DDD のすれ違い

## 「DDD をやりたい」と「CakePHP を捨てたくない」の間で

レイヤードアーキテクチャの純度を高めていくと、  
CakePHP の AutoLoader や規約と衝突する場面が出てきます。

「これは DDD 的に正しいのか？」
「でも CakePHP 的にはこっちが自然じゃないか？」

そんな迷いを感じながら設計している方も多いのではないでしょうか。

本記事では、  
CakePHP を使い続けることを前提に、  
**DDD とどう折り合いをつけるか、その現実的な落とし所**を考えていきます。

# アジェンダ

1. CakePHP の基本構成
2. Controller の扱い
3. Model の扱い
4. View
5. CakePHP × DDD のディレクトリ構成案
6. まとめ

# 1. CakePHP の基本構成

```
src/
├─ Application.php
├─ Controller/
│  └─ AppController.php
├─ Model/
│  ├─ Entity/
│  └─ Table/
├─ View/
│  └─ AppView.php
templates/
```

CakePHP は MVC を前提としたフレームワークであり、

- Controller
- Model（Table / Entity）
- View（templates）

が明確に分離されています。

この構成は CakePHP の規約・AutoLoader・各種ヘルパーと強く結びついており、
ディレクトリ構成を大きく変更すると、フレームワークの恩恵を受けにくくなります。

# 2. Controller の扱い

標準の Controller は App/Controller/AppController を継承して実装されます。
Controller はプレゼンテーション層に属しますので、`Presentation/Controller/xxxController.php` としたくなりますが、
これだと CakePHP の恩恵を受けられません。

| 項目       | CakePHP の規約に従った場合の恩恵             |
| ---------- | -------------------------------------------- |
| AutoLoader | 名前空間・配置を意識せずクラスを解決できる   |
| Routing    | Controller / Action が自動でマッピングされる |
| Middleware | AppController を起点に横断的な制御が可能     |
| Security   | CSRF / Auth などが標準で組み込める           |

そのため、`src/Controller/Api/xxxController.php` のように Controller/ 配下に収めるのが良いと思います。

ミドルウェア的な横断処理（認証・認可やリクエスト制御など）の
振る舞いを Controller 単位で変更したい場合は、
AppController を継承したクラスを用意すると管理しやすくなります。

```php
// src/Controller/Api/ApiController.php
class ApiController extends AppController
{
    // beforeFilter や initialize などで横断的な制御を記述
}
```

以上のことからプレゼンテーション層に属する Controller は CakePHP に**どっぷり依存する**こととなります。
依存すること自体は問題ではなく、Controller の中身にいかに上位モジュールの情報を含めないかがより重要となります。

---

また API を実装する場合は RESTful な設計にするため、CakePHP の規約に従うのが良いかと思います。

### HTTP メソッドを読み込んで自動でメソッドを呼び出す

```php
// src/Api/CustomerController.php
class CustomersController extends AppController
{
    public function index() {}
    public function view() {}
    public function add() {}
    public function patch() {}
    public function delete() {}
}
```

### $routes->resources で HTTP メソッドに応じたメソッドを呼び出す

```php
// app/config/routes.php
return static function (RouteBuilder $routes): void {

    $routes->setRouteClass(DashedRoute::class);

    // API (pure REST)
    $routes->prefix('Api', function (RouteBuilder $routes) {
        $routes->setExtensions(['json']);
        $routes->resources('Customers');
    });
    ...
}
```

> Controller は CakePHP に寄せることで最大の恩恵を受けられます。  
> 重要なのは「依存しないこと」ではなく、  
> **依存する範囲をプレゼンテーション層に閉じ込めること**です。

# 3. Model の扱い

Model は 完全にインフラ層に閉じ込めるのが良いと思います。
そのため Domain Repository の実装は `CakexxxRepository` のように命名する形になります。

```php
// src/Infrastructure/Cake/CakeCustomerRepository.php
class CakeCustomerRepository implements CustomerRepository
{
    public function save(...)
    {
        ...
    }
}
```

ディレクトリは技術ベースで `Cake/` で分けていますが、集約単位で `Customer/CakeCustomerRepository.php` とするのも全然ありだと思います。

一点注意したいのがバリデーションになります。
バリデーションはドメイン層で行うことが多いと思いますが、CakePHP では Model で行われます。
二重で検証が実施されますので、二つのバリデーションルールの競合には注意が必要です。

例えば以下のようなケースが考えられます。

- ドメイン層

  - Email は必須
  - Email は形式チェックを行う

- CakePHP Model
  - email カラムは NOT NULL
  - email カラムは UNIQUE 制約

このように両方でバリデーションを行うと、

- どのレイヤーでエラーを検知するのか
- 例外として扱うのか、バリデーションエラーとして扱うのか

といった責務が曖昧になりやすくなります。

そのため、

- **業務ルールに関わる検証はドメイン層**
- **技術的・永続化都合の検証は Model（Infrastructure）**

といった役割分担を意識することが重要になります。

> バリデーションをどこで行うかは設計判断です。  
> **業務ルールはドメイン層に、技術的制約はインフラ層に**  
> という役割分担を意識することで、責務の衝突を防げます。

# 4. View の扱い

CakePHP4.x 以降は `src/templates/` にビューファイルが配置されます。
View は CakePHP のレンダリング機構と強く結びついているため、  
無理に Domain / Application 側に寄せるメリットは小さいと考えています。

そのため本記事では、
View はインフラ層と割り切り、  
CakePHP の標準構成をそのまま利用します。

# 5. CakePHP × DDD のディレクトリ構成案

以上を踏まえ、本記事での CakePHP × DDD のディレクトリ構成案は以下の通りです。

```
src/
├─ Controller/
│  └─ Api/
│     └─ CustomersController.php
├─ Domain/
│  └─ Customer/
│     ├─ Entity/CustomerEntity.php
│     ├─ Repository/CustomerRepository.php
│     └─ ValueObject/
│        ├─ CustomerId.php
│        ├─ CustomerName.php
│        └─ Email.php
├─ Application/
│  └─ Customer/
│     └─ RegisterCustomerUseCase.php
├─ Infrastructure/
│  └─ Cake/
│     └─ CakeCustomerRepository.php
├─ Model/
│  └─ Table/
│     └─ CustomersTable.php
templates/
```

- Controller / View は CakePHP の規約に従う
- Domain / Application はフレームワーク非依存に保つ
- Model（Table / Entity）は Infrastructure として扱う

この構成により、
CakePHP の利便性と DDD の設計思想を両立しやすくなります。

# 6. まとめ

DDD の理想を追求しすぎると、  
CakePHP が本来提供してくれる規約や仕組みと衝突する場面が出てきます。

重要なのは「純度を高めること」ではなく、
**どこで妥協し、どこは妥協しないかを意識的に選ぶこと**です。

CakePHP を活かしつつ DDD を実践するための一例として、
本記事の構成が参考になれば幸いです。
